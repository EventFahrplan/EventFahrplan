package nerd.tuxmobil.fahrplan.congress.models;

import android.content.Context;
import android.text.TextUtils;

import androidx.annotation.NonNull;
import androidx.core.util.ObjectsCompat;

import info.metadude.android.eventfahrplan.commons.temporal.Moment;
import info.metadude.android.eventfahrplan.network.serialization.FahrplanParser;
import info.metadude.android.eventfahrplan.network.temporal.DateParser;
import nerd.tuxmobil.fahrplan.congress.R;
import nerd.tuxmobil.fahrplan.congress.repositories.SessionsTransformer;

/**
 * Application model representing a lecture, a workshop or any similar time-framed happening.
 */
public class Session {

    public String sessionId;
    public String guid = "";

    public String title;
    public String subtitle;
    public String url;
    public int day;
    public String date;                 // YYYY-MM-DD
    public long dateUTC;                // milliseconds
    public int startTime;               // minutes since day start
    public int relStartTime;            // minutes since conference start
    public int duration;                // minutes

    public String room;

    /**
     * The value of this field is generated by {@link FahrplanParser} when parsing the schedule. It contributes to how
     * the rooms are sorted in the user interface, see {@link SessionsTransformer}. But it should not be used by any
     * other code!
     */
    @Deprecated
    public int roomIndex;

    public String speakers;
    public String track;
    public String type;
    public String lang;
    public String slug;
    public String abstractt;
    public String description;

    public String links;

    public boolean highlight;
    public boolean hasAlarm;

    public String recordingLicense;
    public boolean recordingOptOut;

    public boolean changedTitle;
    public boolean changedSubtitle;
    public boolean changedRoom;
    public boolean changedDay;
    public boolean changedTime;
    public boolean changedDuration;
    public boolean changedSpeakers;
    public boolean changedRecordingOptOut;
    public boolean changedLanguage;
    public boolean changedTrack;
    public boolean changedIsNew;
    public boolean changedIsCanceled;

    private static final boolean RECORDING_OPTOUT_OFF = false;

    public Session(String sessionId) {
        title = "";
        subtitle = "";
        day = 0;
        room = "";
        slug = "";
        startTime = 0;
        duration = 0;
        speakers = "";
        track = "";
        type = "";
        lang = "";
        abstractt = "";
        description = "";
        relStartTime = 0;
        links = "";
        date = "";
        this.sessionId = sessionId;
        highlight = false;
        hasAlarm = false;
        dateUTC = 0;
        roomIndex = 0;
        recordingLicense = "";
        recordingOptOut = RECORDING_OPTOUT_OFF;
        changedTitle = false;
        changedSubtitle = false;
        changedRoom = false;
        changedDay = false;
        changedSpeakers = false;
        changedRecordingOptOut = false;
        changedLanguage = false;
        changedTrack = false;
        changedIsNew = false;
        changedTime = false;
        changedDuration = false;
        changedIsCanceled = false;
    }

    @NonNull
    public String getLinks() {
        return links == null ? "" : links;
    }

    public Moment getStartTimeMoment() {
        long startOfDayTimestamp = DateParser.getDateTime(date);
        return Moment.ofEpochMilli(startOfDayTimestamp).plusMinutes(relStartTime);
    }

    /**
     * Returns the start time in milliseconds.
     * <p>
     * The {@link #dateUTC} is given precedence if its value is bigger then `0`.
     * Otherwise the start time is determined based on {@link #getStartTimeMoment}.
     */
    public long getStartTimeMilliseconds() {
        return (dateUTC > 0) ? dateUTC : getStartTimeMoment().toMilliseconds();
    }

    @SuppressWarnings("RedundantIfStatement")
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Session session = (Session) o;

        if (day != session.day) return false;
        if (duration != session.duration) return false;
        if (recordingOptOut != session.recordingOptOut) return false;
        if (startTime != session.startTime) return false;
        if (!ObjectsCompat.equals(date, session.date)) return false;
        if (!ObjectsCompat.equals(lang, session.lang)) return false;
        if (!sessionId.equals(session.sessionId)) return false;
        if (!ObjectsCompat.equals(recordingLicense, session.recordingLicense)) return false;
        if (!ObjectsCompat.equals(room, session.room)) return false;
        if (!ObjectsCompat.equals(speakers, session.speakers)) return false;
        if (!ObjectsCompat.equals(subtitle, session.subtitle)) return false;
        if (!title.equals(session.title)) return false;
        if (!ObjectsCompat.equals(track, session.track)) return false;
        if (!ObjectsCompat.equals(type, session.type)) return false;
        if (dateUTC != session.dateUTC) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = title.hashCode();
        result = 31 * result + ObjectsCompat.hashCode(subtitle);
        result = 31 * result + day;
        result = 31 * result + ObjectsCompat.hashCode(room);
        result = 31 * result + startTime;
        result = 31 * result + duration;
        result = 31 * result + ObjectsCompat.hashCode(speakers);
        result = 31 * result + ObjectsCompat.hashCode(track);
        result = 31 * result + sessionId.hashCode();
        result = 31 * result + ObjectsCompat.hashCode(type);
        result = 31 * result + ObjectsCompat.hashCode(lang);
        result = 31 * result + ObjectsCompat.hashCode(date);
        result = 31 * result + ObjectsCompat.hashCode(recordingLicense);
        result = 31 * result + (recordingOptOut ? 1 : 0);
        result = 31 * result + (int) dateUTC;
        return result;
    }

    public void cancel() {
        changedIsCanceled = true;
        changedTitle = false;
        changedSubtitle = false;
        changedRoom = false;
        changedDay = false;
        changedSpeakers = false;
        changedRecordingOptOut = false;
        changedLanguage = false;
        changedTrack = false;
        changedIsNew = false;
        changedTime = false;
        changedDuration = false;
    }

    public String getChangedStateString() {
        return "Session{" +
                "changedTitle=" + changedTitle +
                ", changedSubtitle=" + changedSubtitle +
                ", changedRoom=" + changedRoom +
                ", changedDay=" + changedDay +
                ", changedTime=" + changedTime +
                ", changedDuration=" + changedDuration +
                ", changedSpeakers=" + changedSpeakers +
                ", changedRecordingOptOut=" + changedRecordingOptOut +
                ", changedLanguage=" + changedLanguage +
                ", changedTrack=" + changedTrack +
                ", changedIsNew=" + changedIsNew +
                ", changedIsCanceled=" + changedIsCanceled +
                '}';
    }

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    public boolean isChanged() {
        return changedDay || changedDuration ||
                changedLanguage || changedRecordingOptOut ||
                changedRoom || changedSpeakers || changedSubtitle ||
                changedTime || changedTitle || changedTrack;
    }

    public String getFormattedSpeakers() {
        return speakers.replaceAll(";", ", ");
    }

    public String getFormattedTrackText() {
        StringBuilder builder = new StringBuilder();
        builder.append(track);
        if (!TextUtils.isEmpty(lang)) {
            builder.append(" [").append(lang).append("]");
        }
        return builder.toString();
    }

    @NonNull
    public String getFormattedTrackContentDescription(@NonNull Context context) {
        StringBuilder builder = new StringBuilder();
        builder.append(track);
        if (!TextUtils.isEmpty(lang)) {
            builder.append("; ").append(getLanguageContentDescription(context));
        }
        return builder.toString();
    }

    @NonNull
    public String getLanguageContentDescription(@NonNull Context context) {
        if (TextUtils.isEmpty(lang)) {
            return context.getString(R.string.session_list_item_language_unknown_content_description);
        }
        if ("en".equals(lang)) {
            return context.getString(R.string.session_list_item_language_english_content_description);
        }
        if ("de".equals(lang)) {
            return context.getString(R.string.session_list_item_language_german_content_description);
        }
        if ("pt".equals(lang)) {
            return context.getString(R.string.session_list_item_language_portuguese_content_description);
        }
        return context.getString(R.string.session_list_item_language_undefined_content_description, lang);
    }

}
